diff a/.stan/system/stan.system.md b/.stan/system/stan.system.md	(rejected hunks)
@@ -97,6 +97,35 @@
   - New designs MUST propose:
     • Service contracts (ports), orchestration boundaries, and return types,
     • Adapter mappings (CLI flags or other external surfaces → service inputs),
     • Side‑effect boundaries (which ports are required; who prints/writes/copies to clipboard).
   - Prefer many small modules over monoliths (see Cardinal Design Principles). If a proposed service/orchestrator would exceed ~300 LOC, split it before coding.
 
+# Testing architecture (mirrors modules)
+
+- Test pairing is mandatory:
+  - Every non‑trivial module `foo.ts` must have a co‑located `foo.test.ts` that exercises it.
+  - If pairing is “hard,” treat that as a design smell: untestable code is bad code by definition. Return to design and factor the module until it is testable.
+  - If a module is intentionally left without a test, justify why in the module’s header comments (and memorialize that decision); examples: trivial type re‑exports, generated code with external validation, impossible to unit‑test without violating architecture (rare).
+
+- Structure mirrors code:
+  - Co‑locate tests with modules (same directory) and keep naming consistent to make coverage audits and navigation trivial.
+  - The presence of multiple test modules targeting a single artifact (e.g., `runner.test.ts`, `runner.combine.test.ts`) should be an immediate signal to split the artifact into discrete, responsibility‑focused modules that can be tested independently.
+
+- Services/ports vs adapters:
+  - Unit tests focus on services and ports with deterministic behavior; inject fakes/mocks for side‑effect ports (fs/process/network/clipboard).
+  - Adapters (CLI, HTTP, workers, GUIs) get thin smoke tests to validate mapping (flags→service inputs) and presentation‑only concerns; business logic must remain in services.
+
+- Testability and size:
+  - Apply Single‑Responsibility at both module and function level. Prefer small modules and small, composable functions.
+  - If any single test module grows unwieldy, it likely reflects a module doing too much. Return to design and split both the code and its tests accordingly.
+
@@ -279,6 +308,15 @@
 
 - Services‑first proposal required:
   - Before generating code, propose the service contracts (ports), orchestrations, and return types you will add/modify, and specify which ports cover side effects (fs/process/network/clipboard).
   - Propose adapter mappings for each consumer surface:
     • CLI (flags/options → service inputs),
     • and, if applicable, other adapters (HTTP, worker, CI, GUI).
   - Adapters must remain thin: no business logic; no hidden behavior; pure mapping + presentation.
   - Do not emit code until these contracts and mappings are agreed.
   - Apply SRP to modules AND services; if a single unit would exceed ~300 LOC, return to design and propose a split plan (modules, responsibilities, tests).
+
+- Test pairing check (new code):
+  - For every new non‑trivial module you propose, include a paired `*.test.ts`. If you cannot, explain why in the module header comments and treat this as a design smell to resolve soon.
+  - If multiple test files target a single artifact, consider that evidence the artifact should be decomposed into smaller services/modules with their own tests.
 
 - Before proposing or making any code changes, enumerate all source files and flag any file whose length exceeds 300 lines.
 - This rule applies equally to newly generated code:
   - Do not propose or emit a new module that exceeds ~300 lines. Instead, return to design and propose a split plan (modules, responsibilities, tests) before generating code.
 - Present a list of long files (path and approximate LOC). For each file, do one of:
   - Propose how to break it into smaller, testable modules (short rationale and outline), or
   - Document a clear decision to leave it long (with justification tied to requirements).
