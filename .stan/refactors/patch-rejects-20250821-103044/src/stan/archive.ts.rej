diff a/src/stan/archive.ts b/src/stan/archive.ts	(rejected hunks)
@@ -1,20 +1,22 @@
 /* src/stan/archive.ts
  * Create a project archive under the output directory.
  * REQUIREMENTS (updated):
  * - Create <stanPath>/output/archive.tar from project root, excluding node_modules/.git and (by default) stanPath.
  * - Options:
  *   - includeOutputDir?: when true, include the <stanPath>/output directory contents while excluding stanPath/diff and the archive files.
  *   - fileName?: override base name (must end with .tar).
  * - Honor includes/excludes from config (globs supported; includes override excludes).
  * - Return the absolute path to the created tarball.
  * - Maintain previous-archive copy at <stanPath>/diff/archive.prev.tar.
  */
 import { existsSync } from 'node:fs';
-import { copyFile } from 'node:fs/promises';
+import { copyFile, writeFile } from 'node:fs/promises';
 import { resolve } from 'node:path';
 
 import { ensureOutAndDiff, filterFiles, listFiles } from './fs';
+import { classifyForArchive } from './classifier';
 
 type TarLike = {
   create: (
     opts: {
       file: string;
       cwd?: string;
       filter?: (path: string, stat: unknown) => boolean;
     },
@@ -54,6 +56,7 @@ export const createArchive = async (
   });
 
   const archivePath = resolve(outDir, fileName);
   const prevPath = resolve(diffDir, 'archive.prev.tar');
+  const warningsPath = resolve(outDir, 'archive.warnings.txt');
 
   // If an old archive exists in output, copy it to diff before overwriting.
   if (existsSync(archivePath)) {
     try {
       await copyFile(archivePath, prevPath);
@@ -62,6 +65,25 @@ export const createArchive = async (
     }
   }
 
+  // Classify prior to archiving:
+  // - exclude binaries
+  // - flag large text (not excluded)
+  const { textFiles, warningsBody } = await classifyForArchive(cwd, files);
+  const filesForArchive = textFiles;
+
+  // Emit warnings file, always present and included in archives.
+  try {
+    await writeFile(warningsPath, warningsBody, 'utf8');
+  } catch {
+    // best-effort
+  }
+
+  // Helper: ensure warnings file is included even when not packing the whole output directory.
+  const withWarnings = (relList: string[]): string[] => {
+    const warningsRel = `${stanPath.replace(/\\/g, '/')}/output/archive.warnings.txt`;
+    return Array.from(new Set([...relList, warningsRel]));
+  };
+
   const tar = (await import('tar')) as unknown as TarLike;
 
   if (includeOutputDir) {
     // Force-include <stanPath>/output and exclude <stanPath>/diff and archive files.
     const filesToPack = Array.from(
-      new Set([...files, `${stanPath.replace(/\\/g, '/')}/output`]),
+      new Set([...filesForArchive, `${stanPath.replace(/\\/g, '/')}/output`]),
     );
     const isUnder = (prefix: string, p: string): boolean =>
       p === prefix || p.startsWith(`${prefix}/`);
 
     await tar.create(
       {
         file: archivePath,
         cwd,
         filter: (p: string) =>
           !(
             isUnder(`${stanPath}/diff`, p) ||
             p === `${stanPath}/output/archive.tar` ||
             p === `${stanPath}/output/archive.diff.tar`
           ),
       },
       filesToPack,
     );
   } else {
-    await tar.create({ file: archivePath, cwd }, files);
+    await tar.create({ file: archivePath, cwd }, withWarnings(filesForArchive));
   }
 
   // Ensure prev exists on first run.
   if (!existsSync(prevPath)) {
     try {
