diff --git a/package.json b/package.json
index 2b0fa59..e6f7d8b 100644
--- a/package.json
+++ b/package.json
@@ -121,7 +121,7 @@
     "docs": "typedoc",
     "knip": "knip",
     "lint": "eslint .",
     "lint:fix": "eslint --fix .",
     "release": "dotenvx run -f .env.local -- release-it",
     "release:pre": "dotenvx run -f .env.local -- release-it --no-git.requireBranch --github.prerelease --preRelease",
     "stan": "tsx src/cli/stan/index.ts",
-    "stan:build": "rimraf stan.dist && rollup --config stan.rollup.config.ts --configPlugin @rollup/plugin-typescript > stan/build.txt 2>&1 && rimraf stan.dist",
+    "stan:build": "rimraf stan.dist && rollup --config stan.rollup.config.ts --configPlugin @rollup/plugin-typescript > stan/rollup.txt 2>&1 && rimraf stan.dist",
     "test": "vitest --run --coverage",
     "typecheck": "tsc"
   },
diff --git a/src/stan/run.ts b/src/stan/run.ts
index 2a93b1a..c5f1e92 100644
--- a/src/stan/run.ts
+++ b/src/stan/run.ts
@@ -1,12 +1,13 @@
 /* src/stan/run.ts
  * REQUIREMENTS (current + updated):
  * - Execute configured scripts; create per-script artifacts.
  * - Always produce <outputPath>/archive.diff.tar whenever 'archive' is included.
  * - Snapshot update occurs only if one does not exist (create) or via `stan snap`.
  * - NEW: pass updateSnapshot='createIfMissing' to createArchiveDiff.
  * - Combine mode remains; when archive is included, still write archive.diff.tar.
+ * - UPDATED: Render a multi-line, readable plan summary with clear labels.
  */
 import { spawn } from 'node:child_process';
 import { createWriteStream } from 'node:fs';
 import { appendFile, readFile, writeFile } from 'node:fs/promises';
 import { relative, resolve } from 'node:path';
 
@@ -83,33 +84,38 @@ const combineTextOutputs = async (
   await writeFile(combinedPath, sections.join('\n'), 'utf8');
   return combinedPath;
 };
 
-/** Render a short, plain-language summary of the run plan. */
+/** Render a readable, multi-line summary of the run plan. */
 const renderRunPlan = (args: {
   selection: Selection;
   config: ContextConfig;
   mode: ExecutionMode;
   behavior: RunBehavior;
 }): string => {
   const { selection, config, mode, behavior } = args;
 
   const includeArchiveByDefault = selection == null || selection.length === 0;
   const willArchive =
     includeArchiveByDefault ||
     (Array.isArray(selection) && selection.includes('archive'));
 
   // Determine script list shown (exclude 'archive' to avoid confusion)
   const keys = selection == null ? Object.keys(config.scripts) : selection;
   const scripts = (keys ?? []).filter((k) => k !== 'archive');
 
-  const parts = [
-    `STAN will run ${scripts.length.toString()} script(s) (${scripts.join(', ') || 'none'}) ${
-      mode === 'sequential' ? 'sequentially' : 'concurrently'
-    }`,
-    `output: ${config.outputPath}/`,
-    `archive: ${willArchive ? 'yes' : 'no'}`,
-    `combine: ${behavior.combine ? 'yes' : 'no'}`,
-    `diff: ${behavior.diff ? 'yes' : 'no'}`, // retained for compatibility
-    `keep output dir: ${behavior.keep ? 'yes' : 'no'}`,
-  ];
-  return `stan: ${parts.join('; ')}`;
+  const lines = [
+    'STAN run plan',
+    `mode: ${mode === 'sequential' ? 'sequential' : 'concurrent'}`,
+    `output: ${config.outputPath}/`,
+    `scripts: ${scripts.length ? scripts.join(', ') : 'none'}`,
+    `archive: ${willArchive ? 'yes' : 'no'}`,
+    `combine: ${behavior.combine ? 'yes' : 'no'}`,
+    `diff: ${behavior.diff ? 'yes' : 'no'}`, // retained for compatibility
+    `keep output dir: ${behavior.keep ? 'yes' : 'no'}`,
+  ];
+  return `stan:\n  ${lines.join('\n  ')}`;
 };
 
 export const runSelected = async (
   cwd: string,
   config: ContextConfig,
diff --git a/src/cli/stan/init.ts b/src/cli/stan/init.ts
index 3e7f8de..f7a586d 100644
--- a/src/cli/stan/init.ts
+++ b/src/cli/stan/init.ts
@@ -1,22 +1,28 @@
 /* src/cli/stan/init.ts
  * REQUIREMENTS (current + updated):
  * - "stan init" subcommand.
  * - Interactive init when --force is not provided:
  *   - Prompt for outputPath, combinedFileName, includes, excludes, scripts selection.
  * - Defaults in generated stan.config.yml should cover common needs:
  *   - outputPath: stan
  *   - combinedFileName: combined
  *   - excludes: []   <-- UPDATED: no default excludes
  * - Add "/stan" to .gitignore if missing.
  * - Ensure stan.system.md and stan.project.md exist (from dist templates).
  * - After init, create/update the diff snapshot (and log a short message).
  * - Avoid process.exit in tests via exitOverride; swallow help-related codes.
+ *
+ * UPDATED REQUIREMENTS:
+ * - If a config already exists (and --force is not provided), re-run the interactive
+ *   init with defaults prefilled from the existing config.
+ * - Ask for confirmation before resetting the diff snapshot during interactive init.
  */
 import { existsSync } from 'node:fs';
 import { copyFile, readFile, writeFile } from 'node:fs/promises';
 import path from 'node:path';
 import { fileURLToPath } from 'node:url';
 
 import { type Command } from 'commander';
 import { packageDirectorySync } from 'package-directory';
 import YAML from 'yaml';
 
 import type { ContextConfig, ScriptMap } from '@/stan/config';
-import { ensureOutputDir, findConfigPathSync } from '@/stan/config';
+import { ensureOutputDir, findConfigPathSync, loadConfig } from '@/stan/config';
 import { writeArchiveSnapshot } from '@/stan/diff';
 
 /** Swallow Commander exits so tests never call process.exit. */
 const installExitOverride = (cmd: Command): void => {
@@ -117,23 +123,33 @@ const parseCsv = (v: string): string[] =>
   v
     .split(',')
     .map((s) => s.trim())
     .filter((s) => s.length > 0);
 
-/** Prompt for interactive values when not forced. */
+/** Prompt for interactive values when not forced. Supports defaults. */
 const promptForConfig = async (
   cwd: string,
   pkgScripts: Record<string, string>,
+  defaults?: Partial<ContextConfig>,
 ): Promise<
   Pick<
     ContextConfig,
     'outputPath' | 'combinedFileName' | 'includes' | 'excludes' | 'scripts'
-  >
+  > & { resetDiff: boolean }
 > => {
   // Dynamic import to avoid hard dependency at type level.
   const { default: inquirer } = (await import('inquirer')) as {
-    default: { prompt: (qs: unknown[]) => Promise<Record<string, unknown>> };
+    default: {
+      prompt: (qs: unknown[]) => Promise<Record<string, unknown>>;
+    };
   };
 
   const scriptKeys = Object.keys(pkgScripts);
-  const answers = await inquirer.prompt([
+  const defaultSelected = defaults?.scripts
+    ? Object.keys(defaults.scripts).filter((k) => scriptKeys.includes(k))
+    : [];
+
+  const answers = await inquirer.prompt([
     {
       type: 'input',
       name: 'outputPath',
       message: 'Output directory:',
-      default: 'stan',
+      default: defaults?.outputPath ?? 'stan',
     },
     {
       type: 'input',
       name: 'combinedFileName',
       message: 'Base name for combined artifacts:',
-      default: 'combined',
+      default: defaults?.combinedFileName ?? 'combined',
     },
     {
       type: 'input',
       name: 'includes',
       message:
         'Paths to include (CSV; optional; overrides excludes when provided):',
-      default: '',
+      default: (defaults?.includes ?? []).join(','),
     },
     {
       type: 'input',
       name: 'excludes',
       message: 'Paths to exclude (CSV; optional):',
-      default: '',
+      default: (defaults?.excludes ?? []).join(','),
     },
     ...(scriptKeys.length
       ? [
           {
             type: 'checkbox',
             name: 'selectedScripts',
             message: 'Select scripts to include from package.json:',
             choices: scriptKeys.map((k) => ({
               name: `${k}: ${pkgScripts[k]}`,
               value: k,
             })),
+            default: defaultSelected,
             loop: false,
           },
         ]
       : []),
+    {
+      type: 'confirm',
+      name: 'resetDiff',
+      message: 'Reset diff snapshot now?',
+      default: true,
+    },
   ]);
 
   const pick = (n: string, def: string): string => {
     const v = answers[n];
     return typeof v === 'string' && v.trim().length > 0 ? v.trim() : def;
-    // includes/excludes handle empty to [] below
   };
 
-  const out = pick('outputPath', 'stan');
-  const combined = pick('combinedFileName', 'combined');
+  const out = pick('outputPath', defaults?.outputPath ?? 'stan');
+  const combined = pick(
+    'combinedFileName',
+    defaults?.combinedFileName ?? 'combined',
+  );
 
   const includesCsv = (answers['includes'] as string) ?? '';
   const excludesCsv = (answers['excludes'] as string) ?? '';
 
   const selected = Array.isArray(answers.selectedScripts)
@@ -147,10 +163,11 @@ const promptForConfig = async (
   const scripts: ScriptMap = {};
   for (const key of selected) scripts[key] = pkgScripts[key];
 
   return {
     outputPath: out,
     combinedFileName: combined,
     includes: includesCsv ? parseCsv(includesCsv) : [],
     excludes: excludesCsv ? parseCsv(excludesCsv) : [],
     scripts,
+    resetDiff: Boolean(answers.resetDiff),
   };
 };
 
 export const performInit = async (
   _cli: Command,
@@ -158,22 +175,13 @@ export const performInit = async (
   { cwd = process.cwd(), force = false }: { cwd?: string; force?: boolean },
 ): Promise<string | null> => {
   const existing = findConfigPathSync(cwd);
-  if (existing && !force) {
-    // Ensure docs are present even if config already exists.
-    await ensureDocs(cwd);
-    return existing;
-  }
 
   const outRelDefault = 'stan';
   await ensureOutputDir(cwd, outRelDefault, true);
 
   // Base config defaults
   let config: ContextConfig = {
     outputPath: outRelDefault,
     scripts: {},
     combinedFileName: 'combined',
     excludes: [], // UPDATED: no default excludes
     includes: [],
   };
 
-  if (!force) {
-    // Interactive prompts
-    const scripts = await readPackageJsonScripts(cwd);
-    const picked = await promptForConfig(cwd, scripts);
-
-    config = {
-      outputPath: picked.outputPath,
-      combinedFileName: picked.combinedFileName,
-      includes: picked.includes,
-      excludes: picked.excludes,
-      scripts: picked.scripts,
-    };
-  }
+  let resetDiffNow = true;
+  if (!force) {
+    // Use existing config as defaults if present.
+    let defaults: Partial<ContextConfig> | undefined;
+    if (existing) {
+      try {
+        defaults = await loadConfig(cwd);
+      } catch {
+        defaults = undefined;
+      }
+    }
+    const scripts = await readPackageJsonScripts(cwd);
+    const picked = await promptForConfig(cwd, scripts, defaults);
+    config = {
+      outputPath: picked.outputPath,
+      combinedFileName: picked.combinedFileName,
+      includes: picked.includes,
+      excludes: picked.excludes,
+      scripts: picked.scripts,
+    };
+    resetDiffNow = picked.resetDiff;
+  }
 
   const cfgPath = path.join(cwd, 'stan.config.yml');
   const yml = YAML.stringify(config);
   await writeFile(cfgPath, yml, 'utf8');
 
@@ -197,13 +205,20 @@ export const performInit = async (
 
   console.log(`stan: wrote stan.config.yml`);
 
   // Create or replace snapshot after init
-  await writeArchiveSnapshot({
-    cwd,
-    outputPath: config.outputPath,
-    includes: config.includes ?? [],
-    excludes: config.excludes ?? [],
-  });
-  console.log('stan: snapshot updated');
+  if (force || resetDiffNow) {
+    await writeArchiveSnapshot({
+      cwd,
+      outputPath: config.outputPath,
+      includes: config.includes ?? [],
+      excludes: config.excludes ?? [],
+    });
+    console.log('stan: snapshot updated');
+  } else {
+    console.log('stan: snapshot unchanged');
+  }
 
   return cfgPath;
 };
 
 export const registerInit = (cli: Command): Command => {
diff --git a/stan.project.md b/stan.project.md
index 0b2bf2b..f7b3a18 100644
--- a/stan.project.md
+++ b/stan.project.md
@@ -31,15 +31,14 @@
   - `-d/--diff`:
     - When `archive` is included, STAN writes `archive.diff.tar` containing
       only changed files since the last run and maintains
       `<outputPath>/.archive.snapshot.json`.
     - Prior full tar is copied to `archive.prev.tar` before new archive
       creation.
 - Logging:
-  - At the start of `stan run`, print a concise, single‑line plan summary:
-    scripts to run, execution mode (concurrent/sequential), output path,
-    whether archive/combine/diff/keep are enabled.
-  - The plan summary should be structured to look good on a 72‑character‑wide
-    console (clear delimiters, concise labels). Do not hard‑wrap it; keep it a
-    single line.
+  - At the start of `stan run`, print a concise, multi‑line plan summary block
+    with clear labels and indentation. Include: mode, output path, scripts,
+    and whether archive/combine/diff/keep are enabled.
+  - The block should be pleasant to read in typical terminal widths (no need
+    to force a single line).
   - For each script/archive action, log `stan: start "<key>"` and
     `stan: done "<key>" -> <relative path>"`.
diff --git a/refactors/20250819-153000-runplan-init-reset.md b/refactors/20250819-153000-runplan-init-reset.md
new file mode 100644
index 0000000..5e3b9a2
--- /dev/null
+++ b/refactors/20250819-153000-runplan-init-reset.md
@@ -0,0 +1,17 @@
+# Refactor: multiline plan + init reflow
+When: 2025-08-19T15:30:00Z
+Why: Improve UX: 1) Make the stan run plan summary readable with newlines. 2) Re-run interactive init when config exists, using current config as defaults, and confirm diff reset.
+What changed:
+- src/stan/run.ts: renderRunPlan now returns a multi-line, labeled block.
+- src/cli/stan/init.ts: interactive flow runs even with existing config; defaults prefilled; added “Reset diff snapshot now?” confirm; snapshot honored.
+- stan.project.md: logging guideline updated to multi-line plan.
+Tests/Lint:
+- Existing tests do not assert the plan line; no breakage expected. Init force-path still writes snapshot (tests pass).
+- Lint/typecheck unchanged.
+Links:
+- Artifact reference: ctx/test.txt shows prior single-line plan; this change improves readability.
+Next:
+- Optional: Add a smoke test asserting the presence of multi-line plan headers.
